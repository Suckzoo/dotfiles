# cpp Snippets

snippet REP
	for(int ${1:i} = 0; $1 < ${2:n}; ++$1) ${3}
snippet FOR
	for(int ${1:i} = ${2:0}; $1 < ${3:n}; ++$1) ${4}
snippet all
	${1:container}.begin(), $1.end()${2}
snippet unique
	${1:container}.erase(unique($1.begin(), $1.end()), $1.end());${2}
snippet memset
	memset(${1:array}, ${2:0}, sizeof($1));
snippet cin.sync
	cin.sync_with_stdio(false);

snippet pu
	push_back(${1})
snippet using namespace
	using namespace std;

snippet #include
	#include <cassert>
	#include <cmath>
	#include <cstdio>
	#include <cstring>
	#include <string>
	#include <vector>
	#include <queue>
	#include <map>
	#include <set>
	#include <algorithm>
	#include <iostream>
	#include <sstream>
	using namespace std;

snippet main
	int main() {
		cin.sync_with_stdio(false);
		${1}
		return 0;
	}

snippet MACROS
	#define REP(i, n) for(int i = 0; i < (int)(n); ++ i)
	#define FOR(i, b, e) for(auto i = b; i < e; ++ i)
	#define all(x) (x).begin(), (x).end()

	#define CASET int ___T, case_n = 1; scanf("%d ", &___T); while (___T-- > 0)
	#define DEBUG(x) cerr << #x << " = " << x << endl
	#define DEBUGALL(x) { cerr << #x << " = "; for(const auto &e: x) cerr << e << " "; cerr << endl; }

snippet ONLINE_JUDGE
	#ifndef ONLINE_JUDGE
		freopen("${1:problem.in}", "rt", stdin);
	#endif

snippet freopen
	freopen("${1:input.txt}", "rt", stdin);
	freopen("${2:output.txt}", "wt", stdout);



snippet Hopcroft_Karp
	class Hopcroft_Karp {
		//  G(V,E) 
		//  V = { 1, 2, 3, .... V }

		const static  int V = 30000;
		const static  int E = 10101;
		const static  int infinite = 0x7ffffff;
		private : 
		//int v, e;
		int dist[V];
		int Pair_G1[V];
		int Pair_G2[V];

		queue< int > Q;
		vector< vector< int > > adj;
		// G1 U G2 = V
		vector< int > G1;
		vector< int > G2;

		public : 
		Hopcroft_Karp(vector< vector<int> >  newadj, vector<int> newG1, vector<int> newG2 ) {
			adj = newadj;
			G1 = newG1;
			G2 = newG2;
		}

		bool BFS() {
			int size = G1.size();

			for(int i = 0; i < size; ++i) {
				int v = G1[i];
				if ( Pair_G1[v] == 0 ) {
					dist[v] = 0;
					Q.push(v);
				}
				else
					dist[v] = infinite ;
			}

			dist[0] = infinite;

			while ( !Q.empty() ) {
				int v = Q.front();
				Q.pop();
				if ( dist[v] < dist[0] ) {
					size = adj[v].size();
					for(int i = 0; i < size; ++i) {
						int u = adj[v][i];
						if ( dist[ Pair_G2[u] ] == infinite ) {
							dist[ Pair_G2[u] ] = dist[v] + 1;
							Q.push( Pair_G2[u] ) ;
						}
					}
				}
			}
			return dist[0] != infinite;
		}

		bool DFS( int v ) {
			if ( v != 0 ) {
				int size = adj[v].size();
				for(int i = 0; i < size; ++i) {
					int u = adj[v][i];
					if ( dist[ Pair_G2[u]] == dist[v] + 1 ) {
						if ( DFS(Pair_G2[u] ) == true ) {
							Pair_G2[u] = v;
							Pair_G1[v] = u;
							return true;
						}
					}
				}
				return false;
			}
			return true;
		}

		public : int matching() {
			int matchings = 0;
			memset(Pair_G1, 0, sizeof(Pair_G1));
			memset(Pair_G2, 0, sizeof(Pair_G2));

			while( BFS() == true ) {
				int size;
				size = G1.size();
				for(int i = 0; i < size; ++i) {
					int v = G1[i];
					if ( Pair_G1[v] == 0 )
						if ( DFS(v) == true )
							matchings ++;
				}
			}
			return matchings;
		}

	};

snippet unionfind
	int parent[N];
	int get_root( int v )
	{
		if ( parent[v] == v )
			return v;
		return parent[v] = get_root( parent[v] );
	}

	bool Find( int u ,int v )
	{
		return get_root(u) == get_root(v);
	}

	void Union( int u , int v )
	{
		parent[ get_root(u) ] = get_root(v);
	}
