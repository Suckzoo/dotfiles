# cpp Snippets

snippet REP
	for(int ${1:i} = 0; $1 < ${2:n}; ++$1) ${3}
snippet FOR
	for(int ${1:i} = ${2:0}; $1 < ${3:n}; ++$1) ${4}
snippet all
	${1:container}.begin(), $1.end()${2}
snippet unique
	${1:container}.erase(unique($1.begin(), $1.end()), $1.end());${2}
snippet memset
	memset(${1:array}, ${2:0}, sizeof($1));
snippet cin.sync
	cin.sync_with_stdio(false);

snippet pu
	push_back(${1})
snippet using namespace
	using namespace std;

snippet #include
	#include <cassert>
	#include <cmath>
	#include <cstdio>
	#include <cstring>
	#include <string>
	#include <vector>
	#include <queue>
	#include <map>
	#include <set>
	#include <algorithm>
	#include <iostream>
	#include <sstream>
	using namespace std;

	#define REP(i, n) for(int i = 0; i < (int)(n); ++ i)
	#define FOR(i, b, e) for(int i = b; i <= e; ++ i)
	#define FORR(i, b, e) for(int i=b; i>=e; --i)
	#define all(x) (x).begin(), (x).end()
	#define max( a, b ) ( (a) > (b)  ? (a) : (b) )
	#define min( a, b ) ( (a) > (b)  ? (b) : (a) )
	#define CASET int ___T; scanf("%d ", &___T); while (___T-- > 0)
	#define MP make_pair
	#define PB push_back
	#define SZ( (a) ) (a).size()

	#define DEBUG(x) cerr << #x << " = " << x << endl
	#define DEBUGALL(x) { cerr << #x << " = "; for(const auto &e: x) cerr << e << " "; cerr << endl; }

snippet main
	int main() {
		cin.sync_with_stdio(false);
		${1}
		return 0;
	}

snippet MACROS
	#define REP(i, n) for(int i = 0; i < (int)(n); ++ i)
	#define FOR(i, b, e) for(int i = b; i <= e; ++ i)
	#define FORR(i, b, e) for(int i=b; i>=e; --i)
	#define all(x) (x).begin(), (x).end()
	#define max( a, b ) ( (a) > (b)  ? (a) : (b) )
	#define min( a, b ) ( (a) > (b)  ? (b) : (a) )
	#define CASET int ___T; scanf("%d ", &___T); while (___T-- > 0)
	#define MP make_pair
	#define PB push_back
	#define SZ( (a) ) (a).size()

	#define DEBUG(x) cerr << #x << " = " << x << endl
	#define DEBUGALL(x) { cerr << #x << " = "; for(const auto &e: x) cerr << e << " "; cerr << endl; }

snippet ONLINE_JUDGE
	#ifndef ONLINE_JUDGE
		freopen("${1:problem.in}", "rt", stdin);
	#endif

snippet freopen
	freopen("${1:input.txt}", "rt", stdin);
	freopen("${2:output.txt}", "wt", stdout);



snippet Hopcroft_Karp
	class Hopcroft_Karp {
		//  G(V,E) 
		//  V = { 1, 2, 3, .... V }

		const static  int V = 30000;
		const static  int E = 10101;
		const static  int infinite = 0x7ffffff;
		private : 
		//int v, e;
		int dist[V];
		int Pair_G1[V];
		int Pair_G2[V];

		queue< int > Q;
		vector< vector< int > > adj;
		// G1 U G2 = V
		vector< int > G1;
		vector< int > G2;

		public : 
		Hopcroft_Karp(vector< vector<int> >  newadj, vector<int> newG1, vector<int> newG2 ) {
			adj = newadj;
			G1 = newG1;
			G2 = newG2;
		}

		bool BFS() {
			int size = G1.size();

			for(int i = 0; i < size; ++i) {
				int v = G1[i];
				if ( Pair_G1[v] == 0 ) {
					dist[v] = 0;
					Q.push(v);
				}
				else
					dist[v] = infinite ;
			}

			dist[0] = infinite;

			while ( !Q.empty() ) {
				int v = Q.front();
				Q.pop();
				if ( dist[v] < dist[0] ) {
					size = adj[v].size();
					for(int i = 0; i < size; ++i) {
						int u = adj[v][i];
						if ( dist[ Pair_G2[u] ] == infinite ) {
							dist[ Pair_G2[u] ] = dist[v] + 1;
							Q.push( Pair_G2[u] ) ;
						}
					}
				}
			}
			return dist[0] != infinite;
		}

		bool DFS( int v ) {
			if ( v != 0 ) {
				int size = adj[v].size();
				for(int i = 0; i < size; ++i) {
					int u = adj[v][i];
					if ( dist[ Pair_G2[u]] == dist[v] + 1 ) {
						if ( DFS(Pair_G2[u] ) == true ) {
							Pair_G2[u] = v;
							Pair_G1[v] = u;
							return true;
						}
					}
				}
				return false;
			}
			return true;
		}

		public : int matching() {
			int matchings = 0;
			memset(Pair_G1, 0, sizeof(Pair_G1));
			memset(Pair_G2, 0, sizeof(Pair_G2));

			while( BFS() == true ) {
				int size;
				size = G1.size();
				for(int i = 0; i < size; ++i) {
					int v = G1[i];
					if ( Pair_G1[v] == 0 )
						if ( DFS(v) == true )
							matchings ++;
				}
			}
			return matchings;
		}

	};

snippet unionfind
	int parent[N];
	int get_root( int v )
	{
		if ( parent[v] == v )
			return v;
		return parent[v] = get_root( parent[v] );
	}

	bool Find( int u ,int v )
	{
		return get_root(u) == get_root(v);
	}

	void Union( int u , int v )
	{
		parent[ get_root(u) ] = get_root(v);
	}


snippet KMP
	namespace kmp
	{
		typedef vector<int> seq_t;
		void calculate_pi(vector<int>& pi, const seq_t& str) {
			pi[0] = -1;
			int j = -1;
			for (int i = 1 ; i < str.size() ; i++) {
				while (j >= 0 && str[i] != str[j + 1]) j = pi[j];
				if (str[i] == str[j + 1])
					pi[i] = ++j;
				else
					pi[i] = -1;
			}
		}
		/* returns all positions matched */
		vector<int> match(seq_t text, seq_t pattern) {
			vector<int> pi(pattern.size());
			vector<int> ans;
			if (pattern.size() == 0) return ans;
			calculate_pi(pi, pattern);
			int j = -1;
			for (int i = 0 ; i < text.size() ; i++) {
				while (j >= 0 && text[i] != pattern[j + 1]) j = pi[j];
				if (text[i] == pattern[j + 1]) {
					j++;
					if (j + 1 == pattern.size()) {
						ans.push_back(i - j);
						j = pi[j];
					} }
			}
			return ans;
		}
	} // namespace kmp

snippet itree
	class  itree
	{
		typedef long long val_t;
		int size; // 2의 제곱수여야 함
		// 트리를 초기화할 값
		// 예) 구간 최소: 0x7fFFffFF // 구간합: 0
		static const val_t init_value = 0;
		// 트리의 두 child를 병합하는 함수 // 예) 구간 최소: return min(a, b); // 구간합: return a + b;
		 
		val_t sum(val_t a, val_t b) {
			if ( a > b ) return a;
			return b;
		}
		vector< val_t > itree;
		public :
		void init(int n) {
			size = 2;
			while ( size <= n )
				size *=2;
			itree.resize(size*2+1 );
			for (int i = 1 ; i <= size * 2 ; i++)
				itree[i] = init_value;
		}
		void update(int pos, val_t val) {
			pos |= size;
			itree[pos] = val;
			while (pos >>= 1)
				itree[pos] = sum(itree[pos << 1], itree[pos << 1 | 1]);
		}
		val_t getrange(int s, int e) { // [s, e]
			val_t ret = init_value;
			s |= size;
			e |= size;
			while(s <= e) {
				if(s & 1)
					ret = sum(ret, itree[s]);
				if((e & 1) == 0)
					ret = sum(ret, itree[e]);
				s = (s + 1) >> 1;
				e = (e - 1) >> 1;
			}
			return ret; 
		}
	};

snippet itree_adv
	namespace itree
	{
		typedef int val_t;
		const int size = 1024; // 2의 제곱수여야 함
		// 트리를 초기화할 값
		// 예) 구간 최소: 0x7fFFffFF // 구간합: 0
		const val_t init_value = 0;
		// 내부노드 갱신을 위해 가중치를 계산하는 함수 // 예) 구간 최소/최대: return a;
		// 구간 합: return a * len;
		inline val_t weight(val_t a, int len) {
			return a * len;
		}
		// 트리의 두 child를 병합하는 함수 // 예) 구간 최소: return min(a, b); // 구간합: return a + b;
		val_t sum(val_t a, val_t b) {
			return a + b; 
		}
		//노드의 구간 대표값:두child를 병합한 값a와,자신에게 할당된 값b를 병합 // 예) 구간 최소: return min(a, b);
		// 구간합: return a + b;
		val_t update_a(val_t a, val_t b) {
			return a + b; 
		}
		//노드의 구간 대표값:기존의 구간 대표값b1과,새로운 값b2를 병합 
		val_t update_b(val_t b1, val_t b2) {
			return b1 + b2;
		}
		pair<val_t, val_t> itree[size * 2];
		pair<int, int> ptree[size * 2];
		void init() {
			int i;
			for (i = 1 ; i < size * 2 ; i++)
				itree[i] = make_pair(init_value, init_value);
			for (i = size ; i < size * 2 ; i++)
				ptree[i] = make_pair(i, i);
			for (i = size - 1 ; i >= 1 ; i--)
				ptree[i] = make_pair(ptree[i << 1].first, ptree[i << 1 | 1].second);
		}
		void update(int s, int e, val_t val) { // [s, e]
			int s1, e1;
			int d = 0;
			s |= size;
			e |= size;
			s1 = s >> 1;
			e1 = e >> 1;
			while (s <= e) {
				if (s & 1) {
					itree[s].second = update_b(itree[s].second, val);
					val_t child_sum = sum(itree[s << 1].first, itree[s << 1 | 1].first);
					itree[s].first = update_a(
							(s >= size) ? init_value : child_sum,
							weight(itree[s].second, 1 << d));
				}
				if ((e & 1) == 0) {
					itree[e].second = update_b(itree[e].second, val);
					val_t child_sum = sum(itree[e << 1].first, itree[e << 1 | 1].first);
					itree[e].first = update_a(
							(e >= size) ? init_value : child_sum,
							weight(itree[e].second, 1 << d));
				}
				s = (s + 1) >> 1;
				e = (e - 1) >> 1;
				d++;
			}
			d = 1;
			while(s1) {
				itree[s1].first = update_a(
						sum(itree[s1 << 1].first, itree[s1 << 1 | 1].first),
						weight(itree[s1].second, 1 << d));
				itree[e1].first = update_a(
						sum(itree[e1 << 1].first, itree[e1 << 1 | 1].first),
						weight(itree[e1].second, 1 << d));
				s1 >>= 1;
				e1 >>= 1;
				d++;
			}
		}

		val_t _getrange2(int s, int e, int node) {
			if (node >= size)
				return itree[node].first;
			if (s <= ptree[node].first && e >= ptree[node].second)
				return itree[node].first;
			val_t cur = weight(itree[node].second,
					min(e, ptree[node].second) - max(s, ptree[node].first) + 1);
			int left = node << 1;
			int right = node << 1 | 1;
			if(s >= ptree[right].first)
				return update_a(_getrange2(s, e, right), cur);
			else if (e <= ptree[left].second)
				return update_a(_getrange2(s, e, left), cur);
			else
				return update_a(
						sum(_getrange2(s, e, left), _getrange2(s, e, right)),
						cur);
		}
		val_t getrange(int s, int e) { // [s, e]
			if(s > e) return init_value;
			return _getrange2(s | size, e | size, 1);
		}
	} // namespace itree
